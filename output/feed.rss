<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>Mike's programming and architecture blog</title>
		<link>https://mikeska.tech/</link>
		<description>Programming blog about Software Architecture, Angular.io, .NET, ASP.NET, Typescript, programming Comic strips and more</description>
		<copyright>2018</copyright>
		<pubDate>Sun, 07 Oct 2018 19:44:12 GMT</pubDate>
		<lastBuildDate>Sun, 07 Oct 2018 19:44:12 GMT</lastBuildDate>
		<item>
			<title>Create a programming blog without any database or CMS by a static site generator</title>
			<link>https://mikeska.tech/posts/create-programming-blog-without-database-cms-static-site-generator</link>
			<description>&lt;p&gt;One of mine first posts and yes, I'm posting an article how to create a blog.&lt;/p&gt;</description>
			<enclosure url="https://mikeska.tech/title-if.jpg" length="0" type="image" />
			<guid>https://mikeska.tech/posts/create-programming-blog-without-database-cms-static-site-generator</guid>
			<pubDate>Fri, 05 Oct 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;One of mine first posts and yes, I'm posting an article how to create a blog.&lt;/p&gt;
&lt;p&gt;I have now some fresh knowlede and I would like to share with you. Because when I was searching for and article to help me get started fast, I was not very lucky.&lt;/p&gt;
&lt;p&gt;I was not searching an article how to write content, I was searching for an article how to setup my blog technically. Programming blog is more like about content and you should not lose time with a flashy design, the most successful programming bloggers do not have flashy pages as well. Actually their design usually didn't change for maybe last 10 years :)&lt;/p&gt;
&lt;p&gt;So this blog post aims the audience of developers seeking the informations how to create a blog technically.&lt;/p&gt;
&lt;p&gt;It stole most of my evenings in the last month, but now I know a solution which fulfills all these aspects better than I could ever dream of.&lt;/p&gt;
&lt;p&gt;Your blog should be hosted on a second level domain (like myblog.com), should have all the technical necessities, minimum setup, minimum maintenance and running costs as low as possible.&lt;/p&gt;
&lt;p&gt;This posts help you to make a setup like this:&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;aspect&lt;/th&gt;
&lt;th&gt;solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;Second level domain, HTTPS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;features&lt;/td&gt;
&lt;td&gt;Disqucse under every post, Addthis sharing and Full Markdown support&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setup and deployment&lt;/td&gt;
&lt;td&gt;Everything in one Sunday&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;security&lt;/td&gt;
&lt;td&gt;Cannot be hacked, completly care-less&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;maintenance&lt;/td&gt;
&lt;td&gt;None at all&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backups&lt;/td&gt;
&lt;td&gt;Without any effor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hosting cost&lt;/td&gt;
&lt;td&gt;Completly for free&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;I see some possible directions you could go to create a blog about programming. If you belive me I really found the best setup, skip next several chapters and go the the &amp;quot;Static Site Generator&amp;quot;. If you want to know a bit more about my journey, just keep reading the whole article.&lt;/p&gt;
&lt;h2 id="popular-cms-like-wordpress-or-ghost"&gt;Popular CMS like Wordpress or GHost&lt;/h2&gt;
&lt;p&gt;That was actually where my jurney initialy begun. Use one of the popular CMS seemed like the right way to go to be able to start work on the content right away with configuration and development effort.&lt;/p&gt;
&lt;p&gt;But I was surprised a lot by the super-crazy pricing policy of these services. Wordpress.com costs around $400 a year, Ghost is even slighly more pricy. So to create an account directly in a branded CMS was not a way due to the very high price for a non-profit blog.&lt;/p&gt;
&lt;p&gt;At this point it was already clear that if to use any of the open source CMS, it would be Wordpress. Other CMS didn't have Markdown support.&lt;/p&gt;
&lt;p&gt;Branded accouts were too expensive, but there can be found hosting providers on the market which offers deploying a custom instance for much acceptable price, around $180 a year.&lt;/p&gt;
&lt;p&gt;Seemed like that could be it, houndreds of blog templates available, thousands of plug-ins. And after couple of clicks you can start to work on your content right away, your blog is already finished on 95%.&lt;/p&gt;
&lt;p&gt;But unfortunatelly as I later found out, to finish this last 5% can result in terrible pain, especially if you are not a PHP guy :). But the biggest blocker out of all was the lack of a good Markdown editor with syntax highlighting feature.&lt;/p&gt;
&lt;p&gt;Well, I found a one after all, a very good one, but still not perfect. Some of the 3rd party sources it was referencing couldn't get along with my plans to run my website on HTTPS.
On top of that, the development of this plug-in was discontinued.&lt;/p&gt;
&lt;p&gt;Also customizing templates and overall tweeking the application was resulting into the big time waste for even very elementar modifications.&lt;/p&gt;
&lt;p&gt;This was first time I realized that completly custom solution based on technologies much closer to my knowledge could be a better was. I was nearly there, but made a manager decision to drop the Wordpress completly.&lt;/p&gt;
&lt;p&gt;It's possibly a good platform if you want to blog about clothes or lipsticks, but for a blog about programming is it not.&lt;/p&gt;
&lt;h2 id="owncustom-project"&gt;Own/Custom project&lt;/h2&gt;
&lt;p&gt;Well, it's a bit of work, but you are a software developer, you should be able to develop a blog of your own.&lt;/p&gt;
&lt;p&gt;You need a good in Javascript written Markdown editor, simple layer on a web server converting the Markdown into HTML and of couse a database. The very last step would be to give it a design.&lt;/p&gt;
&lt;p&gt;All this is quite easy possible from the developing point of view, but deployment is a bit more complicated situation.&lt;/p&gt;
&lt;p&gt;If you chose to deploy your database and webserver into an own server, this is gonna be cheapest solution, you could end up on $100 a year or maybe even a bit less. But the mayor pitfall here is the time you'll have to spend on the configuration and maintenance. You'll have to take care of all the security updates, sometimes it all gonna go offline because your provider make the server restart and your services are not going to come back up. Sometimes an update after couple of years cause incompatibility with your code and so on.&lt;/p&gt;
&lt;p&gt;More care-free solution would be to use cloud services. Its configuration-less and care-free. One DB service and one Web app do the trick, fast deployed and no care. But you are going to end up on something like $25 a month and this is really a lot for a blog.&lt;/p&gt;
&lt;p&gt;But then I came across one technology...&lt;/p&gt;
&lt;h2 id="static-site-generator"&gt;Static Site Generator&lt;/h2&gt;
&lt;p&gt;I still cannot&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>Comic 1 Your method to override</title>
			<link>https://mikeska.tech/posts/comic1-your-method-to-override</link>
			<description>&lt;p&gt;Do you also wonder why requirements to some of the positions are sometimes so high when it’s often just a junior job?&lt;/p&gt;</description>
			<enclosure url="https://mikeska.tech/title-comic1.png" length="0" type="image" />
			<guid>https://mikeska.tech/posts/comic1-your-method-to-override</guid>
			<pubDate>Sun, 30 Sep 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Do you also wonder why requirements to some of the positions are sometimes so high when it’s often just a junior job?&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/images/strips/your-method-to-override-1.png" class="img-fluid" alt="picture not found" title="Strip your method to override" /&gt;&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>Why you should never evaluate conditional statements inline</title>
			<link>https://mikeska.tech/posts/never-evaluate-conditional-statements-inline</link>
			<description>&lt;p&gt;The conditional statement, conditional expression, conditional construct or commonly known the IF - a fundamental feature of every programming language.&lt;/p&gt;</description>
			<enclosure url="https://mikeska.tech/title-if.jpg" length="0" type="image" />
			<guid>https://mikeska.tech/posts/never-evaluate-conditional-statements-inline</guid>
			<pubDate>Wed, 26 Sep 2018 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;The conditional statement, conditional expression, conditional construct or commonly known the IF - a fundamental feature of every programming language.&lt;/p&gt;
&lt;p&gt;Its right usage doesn't bring benefits just only to you, but also to all the other people participating in the project. Even the programmers whose seniority cannot be put in doubts can author a line of code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;if (this.carType === 'Truck' &amp;amp;&amp;amp; (this.state === this.acitveState || this.item === this.selectedItem)
    &amp;amp;&amp;amp; _.find(this.itemList, {state: 'active'}) &amp;amp;&amp;amp; this.year &amp;gt; 2000)
{
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is wrong with such a line of code? Well, basically everything. It's difficult to read, maintain, debug, refactor or generally make sense of it.&lt;/p&gt;
&lt;p&gt;Consider following dummy code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;public execute1() {
        //here would be typicaly placed a comment trying to describe what
        //is going on in this crazy IF
        if (this.carType === 'Truck' 
            &amp;amp;&amp;amp; (this.state === this.acitveState || this.item === this.selectedItem)
            &amp;amp;&amp;amp; _.find(this.itemList, {state: 'active'}) &amp;amp;&amp;amp; this.year &amp;gt; 2000) 
        {
            this.updateCar();
            this.saveCar();
            this.broadCastUpdates();
        }

        //executing evaluations methods in the if statement is a very bad
        //practice. it's practically undebuggable and if you use it again 
        //in the IF body as a parameter, it might return another value
        if (this.notificationRequired() &amp;amp;&amp;amp; this.matchNotificationRules() 
            &amp;amp;&amp;amp; this.canNotify())
        {
            this.notifyGroup(this.canNotify());
        }

        //this line is maybe not so long and unclear, but doesn't provide 
        //the actual information to the reader, why is the condition 
        //passing or not
        if (['VW', 'AUDI'].includes(this.brand)) {
            this.notifyConcern();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In an entry like this &lt;code&gt;year &amp;gt; 2000&lt;/code&gt; is obvious that to pass the evaluation, the &lt;code&gt;year&lt;/code&gt; must be higher than &lt;code&gt;2000&lt;/code&gt;. And this is exactly the only information provided by the entry.&lt;/p&gt;
&lt;p&gt;The best way how to provide such a information is to encapsulate the evaluation logic into a named method or assign it into a property.&lt;/p&gt;
&lt;p&gt;When a user sees something like &lt;code&gt;let isNotAnOldtimer = year &amp;gt; 2000;&lt;/code&gt;, he is aware that to pass the evaluation, the car must not be an oldtimer. That is significantly more beneficial to the consumer of the method than the plain &lt;code&gt;year &amp;gt; 2000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So let's begin the refactoring by splitting the excessive conditional statements into several short logical parts and give them a name.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;public execute2() {
        //each of these evaluations has one single named results
        //it introduces some new lines to the code, but brings
        //some more sense into it
        let isTruck = this.carType === 'Truck';
        let isActive = this.state === this.acitveState;
        let isSelected = this.item === this.selectedItem;
        let hasItem = !!this.carList.find(this.itemList, {state: 'active'});
        let isNotAnOldtimer = this.year &amp;gt; 2000;

        let canUpdateCar = isTruck &amp;amp;&amp;amp; (isActive || isSelected) &amp;amp;&amp;amp; hasItem &amp;amp;&amp;amp; isNotAnOldtimer;
        if (canUpdateCar)
        {
            this.updateCar();
            this.saveCar();
            this.broadCastUpdates();
        }
        
        //evaluate methods outside the condional statement is a must.
        //you should also consider properties (gets), if you use them in the
        //method body. Their value might change during execution
        let isRequired = this.notificationRequired(); 
        let matchesRule = this.matchNotificationRules() 
        let canNotify = this.canNotify();

        let shouldNotifyGroup = isRequired &amp;amp;&amp;amp; matchesRule &amp;amp;&amp;amp; canNotify;
        if (shouldNotifyGroup) {
            this.notifyGroup();
        }

        //it's better to encapulate even such a single evaluations
        //the statement might be clear to you, but doesn't have to be
        //clear to the others
        let belongsToConcern = ['VW', 'AUDI'].includes(this.brand);
        if (belongsToConcern) {
            this.notifyConcern();
        }
        
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when it has been broken into the several lines, each of them representing one single block of logic, we can read in it like in a book.
You can literally read what is going on in there and while debugging, comfortably step line by line and see the result of each block.&lt;/p&gt;
&lt;p&gt;The new code we introduced during the refactoring might give you an excessive impression. And yes, you are most possibly right.
But our refactoring is not over yet.
One, two, maybe three lines we could keep, but when this threshold reached, the code should be encapsulated into a well-named method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-typescript"&gt;public execute3() {
        //after we put it all into a well name method, user can immediately 
        //see why this condition has passed or not
        let canUpdateCar = this.canUpdateCar();
        if (canUpdateCar) 
        {
            this.updateCar();
            this.saveCar();
            this.broadCastUpdates();
        }

        //while debugging, it really helps to find the bug quick
        let shouldNotifyGroup = this.shouldNotifyGroup();
        if (shouldNotifyGroup) {
            this.notifyGroup();
        }

        //well, no more work to be done in this one-liner, it's short and clear
        let belongsToConcern = ['VW', 'AUDI'].includes(this.brand);
        if (belongsToConcern) {
            this.notifyConcern();
        }
    }

    private canUpdateCar() {
        //inside of this encapsulation is then possible to find what exactly
        //is wrong
        let isTruck = this.carType === 'Truck';
        let isActive = this.state === this.acitveState;
        let isSelected = this.item === this.selectedItem;
        
        let item = !!this.carList.find(this.itemList, {state: 'active'});
        let isNotAnOldtimer = this.year &amp;gt; 2000;

        let canUpdateCar = isTruck &amp;amp;&amp;amp; (isActive || isSelected) &amp;amp;&amp;amp; hasItem &amp;amp;&amp;amp; isNotAnOldtimer;
        return canUpdateCar;
    }
    
    private shouldNotifyGroup() {
        let isRequired = this.notificationRequired(); 
        let matchesRule = this.matchNotificationRules();
        let canNotify = this.canNotify();

        let shouldNotifyGroup = isRequired &amp;amp;&amp;amp; matchesRule &amp;amp;&amp;amp; canNotify;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, there can't be found anything wrong, I admit a was a bit wordy programmer in this example.
But if you manage to stick to this rule for maybe 80-90% of your code, it brings some seniority into your outputs.&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;It's necessary to realize that code you input is not made exclusively for you. You should turn your geeky infinite one-liners into something that makes sense to the future consumers of your code.&lt;/p&gt;
&lt;p&gt;Let's go once more through and point out the major benefits.&lt;/p&gt;
&lt;h3 id="better-sense-of-the-code"&gt;Better sense of the code&lt;/h3&gt;
&lt;p&gt;The user should be able at first sight find out what's the logic flow in your methods. In order to achieve that, naming and encapsulating values inputting the conditional constructs is a must.&lt;/p&gt;
&lt;h3 id="easier-debugging"&gt;Easier debugging&lt;/h3&gt;
&lt;p&gt;It's always a bit tricky to deal with bugs, but well written conditional constructs help to find them. Bugs are not always being made just on the technical level, they occur on the level of business logic as well. Therefore when dealing with well named and formatted code, to fix your business logic is much easier.&lt;/p&gt;
&lt;h3 id="self-documenting-code"&gt;Self-documenting code&lt;/h3&gt;
&lt;p&gt;Encapsulation and right naming produce self-documented code. With such a code is much easier to drag other developers without a deep project knowledge into the project.&lt;/p&gt;
&lt;h3 id="solid-fundament-for-future-refactorings"&gt;Solid fundament for future refactorings&lt;/h3&gt;
&lt;p&gt;Well encapsulated and named code gets you rid of the hassle you might face when the time of refactoring comes. Before you begin to shift your code over the application, it's always better to start with an instant overview about the happening in there.&lt;/p&gt;
</content:encoded>
		</item>
	</channel>
</rss>